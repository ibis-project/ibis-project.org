{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Write your analytics code once, run it everywhere. Main features Ibis provides a standard way to write analytics code, that then can be run in multiple engines. Full coverage of SQL features : You can code in Ibis anything you can implement in a SQL SELECT Transparent to SQL implementation differences : Write standard code that translate to any SQL syntax High performance execution : Execute at the speed of your backend, not your local computer Integration with community data formats and tools (e.g. pandas, Parquet, Avro...) Supported engines Standard DBMS: PostgreSQL , MySQL , SQLite Analytical DBMS: OmniSciDB , ClickHouse Distributed platforms: Impala , PySpark , BigQuery In memory execution: pandas , Dask Example The next example is all the code you need to connect to a database with a countries database, and compute the number of citizens per squared kilometer in Asia: >>> import ibis >>> db = ibis . sqlite . connect ( 'geography.db' ) >>> countries = db . table ( 'countries' ) >>> asian_countries = countries . filter ( countries [ 'continent' ] == 'AS' ) >>> density_in_asia = asian_countries [ 'population' ] . sum () / asian_countries [ 'area_km2' ] . sum () >>> density_in_asia . execute () 130.7019141926602 Learn more about Ibis in our tutorial . Comparison to other tools Why not use pandas ? pandas is great for many use cases. But pandas loads the data into the memory of the local host, and performs the computations on it. Ibis instead, leaves the data in its storage, and performs the computations there. This means that even if your data is distributed, or it requires GPU accelarated speed, Ibis code will be able to benefit from your storage capabilities. Why not use SQL? SQL is widely used and very convenient when writing simple queries. But as the complexity of operations grow, SQL can become very difficult to deal with. With Ibis, you can take fully advantage of software engineering techniques to keep your code readable and maintainable, while writing very complex analytics code. Why not use SQLAlchemy ? SQLAlchemy is very convenient as an ORM (Object Relational Mapper), providing a Python interface to SQL databases. Ibis uses SQLAlchemy internally, but aims to provide a friendlier syntax for analytics code. And Ibis is also not limited to SQL databases, but also can connect to distributed platforms and in-memory representations. Why not use Dask ? Dask provides advanced parallelism, and can distribute pandas jobs. Ibis can process data in a similar way, but for a different number of backends. For example, given a Spark cluster, Ibis allows to perform analytics using it, with a familiar Python syntax. Ibis supports Dask as a backend.","title":"Home"},{"location":"#main-features","text":"Ibis provides a standard way to write analytics code, that then can be run in multiple engines. Full coverage of SQL features : You can code in Ibis anything you can implement in a SQL SELECT Transparent to SQL implementation differences : Write standard code that translate to any SQL syntax High performance execution : Execute at the speed of your backend, not your local computer Integration with community data formats and tools (e.g. pandas, Parquet, Avro...)","title":"Main features"},{"location":"#supported-engines","text":"Standard DBMS: PostgreSQL , MySQL , SQLite Analytical DBMS: OmniSciDB , ClickHouse Distributed platforms: Impala , PySpark , BigQuery In memory execution: pandas , Dask","title":"Supported engines"},{"location":"#example","text":"The next example is all the code you need to connect to a database with a countries database, and compute the number of citizens per squared kilometer in Asia: >>> import ibis >>> db = ibis . sqlite . connect ( 'geography.db' ) >>> countries = db . table ( 'countries' ) >>> asian_countries = countries . filter ( countries [ 'continent' ] == 'AS' ) >>> density_in_asia = asian_countries [ 'population' ] . sum () / asian_countries [ 'area_km2' ] . sum () >>> density_in_asia . execute () 130.7019141926602 Learn more about Ibis in our tutorial .","title":"Example"},{"location":"#comparison-to-other-tools","text":"","title":"Comparison to other tools"},{"location":"#why-not-use-pandas","text":"pandas is great for many use cases. But pandas loads the data into the memory of the local host, and performs the computations on it. Ibis instead, leaves the data in its storage, and performs the computations there. This means that even if your data is distributed, or it requires GPU accelarated speed, Ibis code will be able to benefit from your storage capabilities.","title":"Why not use pandas?"},{"location":"#why-not-use-sql","text":"SQL is widely used and very convenient when writing simple queries. But as the complexity of operations grow, SQL can become very difficult to deal with. With Ibis, you can take fully advantage of software engineering techniques to keep your code readable and maintainable, while writing very complex analytics code.","title":"Why not use SQL?"},{"location":"#why-not-use-sqlalchemy","text":"SQLAlchemy is very convenient as an ORM (Object Relational Mapper), providing a Python interface to SQL databases. Ibis uses SQLAlchemy internally, but aims to provide a friendlier syntax for analytics code. And Ibis is also not limited to SQL databases, but also can connect to distributed platforms and in-memory representations.","title":"Why not use SQLAlchemy?"},{"location":"#why-not-use-dask","text":"Dask provides advanced parallelism, and can distribute pandas jobs. Ibis can process data in a similar way, but for a different number of backends. For example, given a Spark cluster, Ibis allows to perform analytics using it, with a familiar Python syntax. Ibis supports Dask as a backend.","title":"Why not use Dask?"},{"location":"contribute/","text":"Contributing to Ibis Set up a development environment There are two primary ways to setup a development environment. nix : fewer steps, isolated conda : more steps, not isolated Initial steps Dependencies Required git Package Management Warning At least one of nix or conda is required to contribute to ibis. Info As of 2022-01-05 there is experimental support for Python 3.10. However, there are a number of problems with dependencies and development tools that ibis uses and we cannot offically support Python 3.10 until those are fixed. Nix (Linux, Python 3.7-3.9) Miniconda (Linux, Mac, Windows, Python 3.7-3.9) Download and install nix Install gh : nix-shell -p gh # or nix-env -iA gh Fork and clone the ibis repository: # you will likely need to auth, gh will guide you through the steps gh repo fork --clone --remote ibis-project/ibis Run nix-shell in the checkout directory: cd ibis # set up the cache to avoid building everything from scratch nix-shell -p cachix --run 'cachix use ibis' # start a nix-shell # # this may take awhile to download artifacts from the cache nix-shell Download and install Miniconda Install gh conda install -c conda-forge gh Fork and clone the ibis repository: gh repo fork --clone --remote ibis-project/ibis Create a Conda environment from a lock file in the repo: cd ibis conda create -n ibis-dev -f conda-lock/<platform-64-pyver>.lock Activate the environment conda activate ibis-dev Install your local copy of ibis into the Conda environment. In the root of the project run: pip install -e . General workflow Find an issue to work on All contributions are welcome! Code, docs, and constructive feedback are all great contributions to the project. If you don't have a particular issue in mind head over to the GitHub issue tracker for Ibis and look for open issues with the label good first issue . Feel free to help with other issues that aren't labeled as such, but they may be more challenging. Once you find an issue you want to work on, write a comment with the text /take on the issue. GitHub will then assign the issue to you. This lets people know you're working on the issue. If you find an issue that has an assignee, comment on the issue and ask whether the assignee is still working on the issue. Make a branch The first thing you want to do is make a branch. Let's call it useful-bugfix : git checkout -b useful-bugfix Make the desired change Let's say you've made a change to ibis/expr/types.py to fix a bug reported in issue #424242 (not actually an issue). Running git status should give output similar to this: $ git status On branch useful-bugfix Your branch is up to date with 'origin/useful-bugfix' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: ibis/expr/types.py no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Run the test suite Next, you'll want to run a subset of the test suite. Dependencies Required nix environment or conda environment To run a subset of the ibis tests use the following command: PYTEST_BACKENDS = \"sqlite pandas\" pytest ibis/tests ibis/backends/tests You can change PYTEST_BACKENDS=\"sqlite pandas\" to include one or more space-separated supported backends that you want to test. It isn't necessary to provide PYTEST_BACKENDS at all, but it's useful for exercising more of the library's test suite. Commit your changes Dependencies Required git cz Tip cz is already installed in your environment if you followed the setup instructions Next, you'll want to commit your changes. Ibis's commit message structure follows semantic-release conventions . Warning It isn't necessary to use cz commit to make commits, but it is necessary to follow the instructions outlined in this table in this table . Stage your changes and run cz commit : $ git add . $ cz commit You should see a series of prompts about actions to take next: Select the type of change you're committing. In this case, we're committing a bug fix, so we'll select fix: ? Select the type of change you are committing (Use arrow keys) \u00bb fix: A bug fix. Correlates with PATCH in SemVer feat: A new feature. Correlates with MINOR in SemVer docs: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor: A code change that neither fixes a bug nor adds a feature perf: A code change that improves performance test: Adding missing or correcting existing tests build: Changes that affect the build system or external dependencies (example scopes: pip, docker, npm) ci: Changes to our CI configuration files and scripts (example scopes: GitLabCI) Generally you don't need to think too hard about what category to select, but note that: feat will cause a minor version bump fix will cause a patch version bump everything else will not cause a version bump, unless it's a breaking change (continue reading these instructions for more info on that) Next, you're asked what the scope of this change is: ? What is the scope of this change? (class or file name): (press [enter] to skip) This is optional, but if there's a clear component or single file that is modified you should put it. In our case, let's assume the bug fixed a type inference problem, so we'd type in type-inference at this prompt. You'll then be asked to type in a short description of the change which will be the commit message title: ? Write a short and imperative summary of the code changes: (lower case and no period) fix a type inference issue where floats were incorrectly cast to ints Let's say there was a problem with spurious casting of float to integers, so we type in the message above. That number on the left (here (69) ) is the length of description you've typed in. Next you'll be asked for a longer description, which is entirely optional unless the change is a breaking change , or you feel like a bit of prose ? Provide additional contextual information about the code changes: (press [enter] to skip) A bug was triggered by some incorrect code that caused floats to be incorrectly cast to integers. For non breaking changes, this isn't strictly necessary but it can be very helpful when a change is large, obscure, or complex. For this example let's just reiterate most of what the commit title says. Next you're asked about breaking changes: ? Is this a BREAKING CHANGE? Correlates with MAJOR in SemVer (y/N) If you answer y , then you'll get an additional prompt asking you to describe the breaking changes. This description will ultimately make its way into the user-facing release notes. If there aren't any breaking changes, press enter. Let's say this bug fix does not introduce a breaking change. Finally, you're asked whether this change affects any open issues (ignore the bit about breaking changes) and if yes then to reference them: ? Footer. Information about Breaking Changes and reference issues that this commit closes: (press [enter] to skip) fixes #424242 Here we typed fixes #424242 to indicate that we fixed issue #9000. Whew! Seems like a lot, but it's rather quick once you get used to it. After that you should have a commit that looks roughly like this, ready to be automatically rolled into the next release: commit 4049adbd66b0df48e37ca105da0b9139101a1318 (HEAD -> useful-bugfix) Author: Phillip Cloud <417981+cpcloud@users.noreply.github.com> Date: Tue Dec 21 10:30:50 2021 -0500 fix(type-inference): fix a type inference issue where floats were incorrectly cast to ints A bug was triggered by some incorrect code that caused floats to be incorrectly cast to integers. fixes #424242 Push your changes Now that you've got a commit, you're ready to push your changes and make a pull request! gh pr create Follow the prompts, and gh will print a link to your PR upon successfuly submission. Updating dependencies Automatic dependency updates WhiteSource Renovate will run at some cadence (outside of traditional business hours) and submit PRs that update dependencies. These upgrades use a conservative update strategy, which is currently to increase the upper bound of a dependency's range. The PRs it generates will regenerate a number of other files so that in most cases contributors do not have to remember to generate and commit these files. Manually updating dependencies Danger Do not manually edit setup.py , it is automatically generated from pyproject.toml Edit pyproject.toml as needed. Run poetry update Run # if using nix $ ./dev/poetry2setup -o setup.py # it not using nix, requires installation of tomli and poetry-core $ PYTHONHASHSEED = 42 python ./dev/poetry2setup.py -o setup.py from the repository root. Updates of minor and patch versions of dependencies are handled automatically by renovate . Releasing Style and formatting The following tools are run in both CI and pre-commit checks to ensure codebase hygiene: Tool Purpose black Formatting Python code isort Formatting and sorting import statements flake8 Linting Python code nix-linter Linting nix files nixpkgs-fmt Formatting nix files shellcheck Linting shell scripts shfmt Formatting shell scripts pyupgrade Ensuring the latest available Python syntax is used Tip If you use nix-shell all of these are setup for you and ready to use, you don't need to install any of these tools. We use numpydoc as our standard format for docstrings. Commit philosophy We aim to make our individual commits small and tightly focused on the feature they are implementing or bug being fixed. If you find yourself making functional changes to different areas of the codebase, we prefer you break up your changes into separate Pull Requests. In general, a philosophy of one Github Issue per Pull Request is a good rule of thumb. Maintainer's guide Maintainers should be performing a minimum number of tasks, deferring to automation as much as possible: Reviewing pull requests Merging pull requests A number of tasks that are typically associated with maintenance are partially or fully automated: Updating library dependencies: this is handled automatically by WhiteSource Renovate Updating github-actions: this is handled automatically by WhiteSource Renovate Updating nix dependencies: this is a job run at a regular cadence to update nix dependencies Occasionally you may need to manually lock poetry dependencies, which can be done by running poetry update --lock If a dependency was updated, you'll see changes to poetry.lock in the current directory. Merging PRs PRs can be merged using the gh command line tool or with the GitHub web UI. Release PyPI Releases to PyPI are handled automatically using a Python implementation of semantic release . Ibis is released in two places: PyPI , to enable pip install ibis-framework Conda Forge , to enable conda install ibis-framework conda-forge The conda-forge package is released using the conda-forge feedstock repository After a release to PyPI, the conda-forge bot automatically updates the ibis package.","title":"Contribute"},{"location":"contribute/#contributing-to-ibis","text":"","title":"Contributing to Ibis"},{"location":"contribute/#set-up-a-development-environment","text":"There are two primary ways to setup a development environment. nix : fewer steps, isolated conda : more steps, not isolated","title":"Set up a development environment"},{"location":"contribute/#initial-steps","text":"","title":"Initial steps"},{"location":"contribute/#dependencies","text":"","title":"Dependencies"},{"location":"contribute/#required","text":"git","title":"Required"},{"location":"contribute/#package-management","text":"Warning At least one of nix or conda is required to contribute to ibis. Info As of 2022-01-05 there is experimental support for Python 3.10. However, there are a number of problems with dependencies and development tools that ibis uses and we cannot offically support Python 3.10 until those are fixed. Nix (Linux, Python 3.7-3.9) Miniconda (Linux, Mac, Windows, Python 3.7-3.9) Download and install nix Install gh : nix-shell -p gh # or nix-env -iA gh Fork and clone the ibis repository: # you will likely need to auth, gh will guide you through the steps gh repo fork --clone --remote ibis-project/ibis Run nix-shell in the checkout directory: cd ibis # set up the cache to avoid building everything from scratch nix-shell -p cachix --run 'cachix use ibis' # start a nix-shell # # this may take awhile to download artifacts from the cache nix-shell Download and install Miniconda Install gh conda install -c conda-forge gh Fork and clone the ibis repository: gh repo fork --clone --remote ibis-project/ibis Create a Conda environment from a lock file in the repo: cd ibis conda create -n ibis-dev -f conda-lock/<platform-64-pyver>.lock Activate the environment conda activate ibis-dev Install your local copy of ibis into the Conda environment. In the root of the project run: pip install -e .","title":"Package Management"},{"location":"contribute/#general-workflow","text":"","title":"General workflow"},{"location":"contribute/#find-an-issue-to-work-on","text":"All contributions are welcome! Code, docs, and constructive feedback are all great contributions to the project. If you don't have a particular issue in mind head over to the GitHub issue tracker for Ibis and look for open issues with the label good first issue . Feel free to help with other issues that aren't labeled as such, but they may be more challenging. Once you find an issue you want to work on, write a comment with the text /take on the issue. GitHub will then assign the issue to you. This lets people know you're working on the issue. If you find an issue that has an assignee, comment on the issue and ask whether the assignee is still working on the issue.","title":"Find an issue to work on"},{"location":"contribute/#make-a-branch","text":"The first thing you want to do is make a branch. Let's call it useful-bugfix : git checkout -b useful-bugfix","title":"Make a branch"},{"location":"contribute/#make-the-desired-change","text":"Let's say you've made a change to ibis/expr/types.py to fix a bug reported in issue #424242 (not actually an issue). Running git status should give output similar to this: $ git status On branch useful-bugfix Your branch is up to date with 'origin/useful-bugfix' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: ibis/expr/types.py no changes added to commit ( use \"git add\" and/or \"git commit -a\" )","title":"Make the desired change"},{"location":"contribute/#run-the-test-suite","text":"Next, you'll want to run a subset of the test suite.","title":"Run the test suite"},{"location":"contribute/#dependencies_1","text":"","title":"Dependencies"},{"location":"contribute/#required_1","text":"nix environment or conda environment To run a subset of the ibis tests use the following command: PYTEST_BACKENDS = \"sqlite pandas\" pytest ibis/tests ibis/backends/tests You can change PYTEST_BACKENDS=\"sqlite pandas\" to include one or more space-separated supported backends that you want to test. It isn't necessary to provide PYTEST_BACKENDS at all, but it's useful for exercising more of the library's test suite.","title":"Required"},{"location":"contribute/#commit-your-changes","text":"","title":"Commit your changes"},{"location":"contribute/#dependencies_2","text":"","title":"Dependencies"},{"location":"contribute/#required_2","text":"git cz Tip cz is already installed in your environment if you followed the setup instructions Next, you'll want to commit your changes. Ibis's commit message structure follows semantic-release conventions . Warning It isn't necessary to use cz commit to make commits, but it is necessary to follow the instructions outlined in this table in this table . Stage your changes and run cz commit : $ git add . $ cz commit You should see a series of prompts about actions to take next: Select the type of change you're committing. In this case, we're committing a bug fix, so we'll select fix: ? Select the type of change you are committing (Use arrow keys) \u00bb fix: A bug fix. Correlates with PATCH in SemVer feat: A new feature. Correlates with MINOR in SemVer docs: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor: A code change that neither fixes a bug nor adds a feature perf: A code change that improves performance test: Adding missing or correcting existing tests build: Changes that affect the build system or external dependencies (example scopes: pip, docker, npm) ci: Changes to our CI configuration files and scripts (example scopes: GitLabCI) Generally you don't need to think too hard about what category to select, but note that: feat will cause a minor version bump fix will cause a patch version bump everything else will not cause a version bump, unless it's a breaking change (continue reading these instructions for more info on that) Next, you're asked what the scope of this change is: ? What is the scope of this change? (class or file name): (press [enter] to skip) This is optional, but if there's a clear component or single file that is modified you should put it. In our case, let's assume the bug fixed a type inference problem, so we'd type in type-inference at this prompt. You'll then be asked to type in a short description of the change which will be the commit message title: ? Write a short and imperative summary of the code changes: (lower case and no period) fix a type inference issue where floats were incorrectly cast to ints Let's say there was a problem with spurious casting of float to integers, so we type in the message above. That number on the left (here (69) ) is the length of description you've typed in. Next you'll be asked for a longer description, which is entirely optional unless the change is a breaking change , or you feel like a bit of prose ? Provide additional contextual information about the code changes: (press [enter] to skip) A bug was triggered by some incorrect code that caused floats to be incorrectly cast to integers. For non breaking changes, this isn't strictly necessary but it can be very helpful when a change is large, obscure, or complex. For this example let's just reiterate most of what the commit title says. Next you're asked about breaking changes: ? Is this a BREAKING CHANGE? Correlates with MAJOR in SemVer (y/N) If you answer y , then you'll get an additional prompt asking you to describe the breaking changes. This description will ultimately make its way into the user-facing release notes. If there aren't any breaking changes, press enter. Let's say this bug fix does not introduce a breaking change. Finally, you're asked whether this change affects any open issues (ignore the bit about breaking changes) and if yes then to reference them: ? Footer. Information about Breaking Changes and reference issues that this commit closes: (press [enter] to skip) fixes #424242 Here we typed fixes #424242 to indicate that we fixed issue #9000. Whew! Seems like a lot, but it's rather quick once you get used to it. After that you should have a commit that looks roughly like this, ready to be automatically rolled into the next release: commit 4049adbd66b0df48e37ca105da0b9139101a1318 (HEAD -> useful-bugfix) Author: Phillip Cloud <417981+cpcloud@users.noreply.github.com> Date: Tue Dec 21 10:30:50 2021 -0500 fix(type-inference): fix a type inference issue where floats were incorrectly cast to ints A bug was triggered by some incorrect code that caused floats to be incorrectly cast to integers. fixes #424242","title":"Required"},{"location":"contribute/#push-your-changes","text":"Now that you've got a commit, you're ready to push your changes and make a pull request! gh pr create Follow the prompts, and gh will print a link to your PR upon successfuly submission.","title":"Push your changes"},{"location":"contribute/#updating-dependencies","text":"","title":"Updating dependencies"},{"location":"contribute/#automatic-dependency-updates","text":"WhiteSource Renovate will run at some cadence (outside of traditional business hours) and submit PRs that update dependencies. These upgrades use a conservative update strategy, which is currently to increase the upper bound of a dependency's range. The PRs it generates will regenerate a number of other files so that in most cases contributors do not have to remember to generate and commit these files.","title":"Automatic dependency updates"},{"location":"contribute/#manually-updating-dependencies","text":"Danger Do not manually edit setup.py , it is automatically generated from pyproject.toml Edit pyproject.toml as needed. Run poetry update Run # if using nix $ ./dev/poetry2setup -o setup.py # it not using nix, requires installation of tomli and poetry-core $ PYTHONHASHSEED = 42 python ./dev/poetry2setup.py -o setup.py from the repository root. Updates of minor and patch versions of dependencies are handled automatically by renovate .","title":"Manually updating dependencies"},{"location":"contribute/#releasing","text":"","title":"Releasing"},{"location":"contribute/#style-and-formatting","text":"The following tools are run in both CI and pre-commit checks to ensure codebase hygiene: Tool Purpose black Formatting Python code isort Formatting and sorting import statements flake8 Linting Python code nix-linter Linting nix files nixpkgs-fmt Formatting nix files shellcheck Linting shell scripts shfmt Formatting shell scripts pyupgrade Ensuring the latest available Python syntax is used Tip If you use nix-shell all of these are setup for you and ready to use, you don't need to install any of these tools. We use numpydoc as our standard format for docstrings.","title":"Style and formatting"},{"location":"contribute/#commit-philosophy","text":"We aim to make our individual commits small and tightly focused on the feature they are implementing or bug being fixed. If you find yourself making functional changes to different areas of the codebase, we prefer you break up your changes into separate Pull Requests. In general, a philosophy of one Github Issue per Pull Request is a good rule of thumb.","title":"Commit philosophy"},{"location":"contribute/#maintainers-guide","text":"Maintainers should be performing a minimum number of tasks, deferring to automation as much as possible: Reviewing pull requests Merging pull requests A number of tasks that are typically associated with maintenance are partially or fully automated: Updating library dependencies: this is handled automatically by WhiteSource Renovate Updating github-actions: this is handled automatically by WhiteSource Renovate Updating nix dependencies: this is a job run at a regular cadence to update nix dependencies Occasionally you may need to manually lock poetry dependencies, which can be done by running poetry update --lock If a dependency was updated, you'll see changes to poetry.lock in the current directory.","title":"Maintainer's guide"},{"location":"contribute/#merging-prs","text":"PRs can be merged using the gh command line tool or with the GitHub web UI.","title":"Merging PRs"},{"location":"contribute/#release","text":"","title":"Release"},{"location":"contribute/#pypi","text":"Releases to PyPI are handled automatically using a Python implementation of semantic release . Ibis is released in two places: PyPI , to enable pip install ibis-framework Conda Forge , to enable conda install ibis-framework","title":"PyPI"},{"location":"contribute/#conda-forge","text":"The conda-forge package is released using the conda-forge feedstock repository After a release to PyPI, the conda-forge bot automatically updates the ibis package.","title":"conda-forge"},{"location":"getting_started/","text":"Getting started Installation instructions The next steps show the recommended way of installing ibis. Other installation options can be found in the advanced installation page . Download Anaconda for your operating system and the latest Python version, run the installer, and follow the steps. Detailed instructions on how to install Anaconda can be found in the Anaconda documentation ). In a shell prompt install ibis-framework : conda install -c conda-forge ibis-framework In the same shell prompt, import ibis and print its version python -c 'import ibis; print(ibis.__version__)' You're ready to start using ibis! Tutorials Learn more about ibis in the tutorials !","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting started"},{"location":"getting_started/#installation-instructions","text":"The next steps show the recommended way of installing ibis. Other installation options can be found in the advanced installation page . Download Anaconda for your operating system and the latest Python version, run the installer, and follow the steps. Detailed instructions on how to install Anaconda can be found in the Anaconda documentation ). In a shell prompt install ibis-framework : conda install -c conda-forge ibis-framework In the same shell prompt, import ibis and print its version python -c 'import ibis; print(ibis.__version__)' You're ready to start using ibis!","title":"Installation instructions"},{"location":"getting_started/#tutorials","text":"Learn more about ibis in the tutorials !","title":"Tutorials"},{"location":"release_notes/","text":"Release Notes","title":"Release Notes"},{"location":"release_notes/#release-notes","text":"","title":"Release Notes"},{"location":"about/","text":"Ibis: Python Data Analysis Productivity Framework Ibis is a toolbox to bridge the gap between local Python environments (like pandas and scikit-learn) and remote storage and execution systems like Hadoop components (like HDFS, Impala, Hive, Spark) and SQL databases (Postgres, etc.). Its goal is to simplify analytical workflows and make you more productive. We have a handful of specific priority focus areas: Enable data analysts to translate local, single-node data idioms to scalable computation representations (e.g. SQL or Spark) Integration with pandas and other Python data ecosystem components Provide high level analytics APIs and workflow tools to enhance productivity and streamline common or tedious tasks. Integration with community standard data formats (e.g. Parquet and Avro) Abstract away database-specific SQL differences As the Apache Arrow project develops, we will look to use Arrow to enable computational code written in Python to be executed natively within other systems like Apache Spark and Apache Impala (incubating). Source code is on GitHub: https://github.com/ibis-project/ibis .","title":"Introduction"},{"location":"about/#ibis-python-data-analysis-productivity-framework","text":"Ibis is a toolbox to bridge the gap between local Python environments (like pandas and scikit-learn) and remote storage and execution systems like Hadoop components (like HDFS, Impala, Hive, Spark) and SQL databases (Postgres, etc.). Its goal is to simplify analytical workflows and make you more productive. We have a handful of specific priority focus areas: Enable data analysts to translate local, single-node data idioms to scalable computation representations (e.g. SQL or Spark) Integration with pandas and other Python data ecosystem components Provide high level analytics APIs and workflow tools to enhance productivity and streamline common or tedious tasks. Integration with community standard data formats (e.g. Parquet and Avro) Abstract away database-specific SQL differences As the Apache Arrow project develops, we will look to use Arrow to enable computational code written in Python to be executed natively within other systems like Apache Spark and Apache Impala (incubating). Source code is on GitHub: https://github.com/ibis-project/ibis .","title":"Ibis: Python Data Analysis Productivity Framework"},{"location":"about/license/","text":"Legal Ibis is distributed under the Apache License, Version 2.0. Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"about/license/#legal","text":"Ibis is distributed under the Apache License, Version 2.0. Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Legal"},{"location":"about/roadmap/","text":"Roadmap This document is an outline of the next set of major efforts within ibis. Long Term Goals This section outlines broader, longer-term goals for the project alongside a few short-term goals and provides information and direction for a few key areas of focus over the next 1-2 years, possibly longer depending on the amount of time the developers of Ibis can devote to the project. Compiler Structure Separation of Concerns The current architecture of the ibis compiler has a few key problems that need to be addressed to ensure longevity and maintainability of the project going forward. The main structural problem is that there isn\u2019t one place where expression optimizations and transformations happen. Sometimes optimizations occur as an expression is being built, and other times they occur on a whole expression. The solution is to separate the expression construction and optimization into two phases, and guarantee that a constructed expression, if compiled without optimization, maps clearly to SQL constructs. The optimization pass would happen just before compilation and would be free to optimize whole expression trees. This approach lets us optimize queries piece by piece, as opposed to having to provide all optimization implementations in a single pull request. Unifying Table and Column Compilation Right now, it is very difficult to customize the way the operations underlying table expressions are compiled. The logic to compile them is hard-coded in each backend (or the compiler\u2019s parent class). This needs to be addressed, if only to ease the burden of implementing the UNNEST operation and make the codebase easier to understand and maintain. Depth \"Depth\" goals relate to enhancing Ibis to provide better support for backend-specific functionality. Backend-Specific Operations As the number of ibis users and use cases grows there will be an increasing need for individual backends to support more exotic operations. Many SQL databases have features that are unique only to themselves and often this is why people will choose that technology over another. Ibis should support an API that reflects the backend that underlies an expression and expose the functionality of that specific backend. A concrete example of this is the FARM_FINGERPRINT function in BigQuery. It is unlikely that the main ValueExpr API will ever grow such a method, but a BigQuery user shouldn\u2019t be restricted to using only the methods this API provides. Moreover, users should be able to bring their own methods to this API without having to consult the ibis developers and without the addition of such operations polluting the namespace of the main API. One drawback to enabling this is that it provides an incentive for people to define operations with a backend-specific spelling (presumably in the name of expediency) that may actually be easily generalizable to or useful for other backends. This behavior should be discouraged to the extent possible. Standardize UDFs (User Defined Functions) A few backends have support for UDFs. Impala, Pandas and BigQuery all have at least some level of support for user-defined functions. This mechanism should be extended to other backends where possible. We outline different approaches to adding UDFs to the backends that are well-supported but currently do not have a UDF implementation. Development of a standard interface for UDFs is ideal, so that it\u2019s easy for new backends to implement the interface. Breadth The major breadth-related question ibis is facing is how to grow the number of backends in ibis in a scalable, minimum-maintenance way is an open question. Currently there is a test suite that runs across all backends that xfails tests when a backend doesn\u2019t implement a particular operation. At minimum we need a way to display which backends implement which operations. With the ability to provide custom operations we also need a way to display the custom operations that each backend provides. Backend-Specific Goals These goals relate to specific backends pandas Speed up grouped, rolling, and simple aggregations using numba pandas aggregations are quite slow relative to an equivalent numba implementation, for various reasons. Since ibis hides the implementation details of a particular expression we can experiment with using different aggregation implementations. Dask Implement a Dask backend There is currently no way in ibis to easily parallelize a computation on a single machine, let alone distribute a computation across machines. Dask provides APIs for doing such things. Spark Implement a SparkSQL backend SparkSQL provides a way to execute distributed SQL queries similar to other backends supported by ibis such as Impala and BigQuery.","title":"Roadmap"},{"location":"about/roadmap/#roadmap","text":"This document is an outline of the next set of major efforts within ibis.","title":"Roadmap"},{"location":"about/roadmap/#long-term-goals","text":"This section outlines broader, longer-term goals for the project alongside a few short-term goals and provides information and direction for a few key areas of focus over the next 1-2 years, possibly longer depending on the amount of time the developers of Ibis can devote to the project.","title":"Long Term Goals"},{"location":"about/roadmap/#compiler-structure","text":"","title":"Compiler Structure"},{"location":"about/roadmap/#separation-of-concerns","text":"The current architecture of the ibis compiler has a few key problems that need to be addressed to ensure longevity and maintainability of the project going forward. The main structural problem is that there isn\u2019t one place where expression optimizations and transformations happen. Sometimes optimizations occur as an expression is being built, and other times they occur on a whole expression. The solution is to separate the expression construction and optimization into two phases, and guarantee that a constructed expression, if compiled without optimization, maps clearly to SQL constructs. The optimization pass would happen just before compilation and would be free to optimize whole expression trees. This approach lets us optimize queries piece by piece, as opposed to having to provide all optimization implementations in a single pull request.","title":"Separation of Concerns"},{"location":"about/roadmap/#unifying-table-and-column-compilation","text":"Right now, it is very difficult to customize the way the operations underlying table expressions are compiled. The logic to compile them is hard-coded in each backend (or the compiler\u2019s parent class). This needs to be addressed, if only to ease the burden of implementing the UNNEST operation and make the codebase easier to understand and maintain.","title":"Unifying Table and Column Compilation"},{"location":"about/roadmap/#depth","text":"\"Depth\" goals relate to enhancing Ibis to provide better support for backend-specific functionality.","title":"Depth"},{"location":"about/roadmap/#backend-specific-operations","text":"As the number of ibis users and use cases grows there will be an increasing need for individual backends to support more exotic operations. Many SQL databases have features that are unique only to themselves and often this is why people will choose that technology over another. Ibis should support an API that reflects the backend that underlies an expression and expose the functionality of that specific backend. A concrete example of this is the FARM_FINGERPRINT function in BigQuery. It is unlikely that the main ValueExpr API will ever grow such a method, but a BigQuery user shouldn\u2019t be restricted to using only the methods this API provides. Moreover, users should be able to bring their own methods to this API without having to consult the ibis developers and without the addition of such operations polluting the namespace of the main API. One drawback to enabling this is that it provides an incentive for people to define operations with a backend-specific spelling (presumably in the name of expediency) that may actually be easily generalizable to or useful for other backends. This behavior should be discouraged to the extent possible.","title":"Backend-Specific Operations"},{"location":"about/roadmap/#standardize-udfs-user-defined-functions","text":"A few backends have support for UDFs. Impala, Pandas and BigQuery all have at least some level of support for user-defined functions. This mechanism should be extended to other backends where possible. We outline different approaches to adding UDFs to the backends that are well-supported but currently do not have a UDF implementation. Development of a standard interface for UDFs is ideal, so that it\u2019s easy for new backends to implement the interface.","title":"Standardize UDFs (User Defined Functions)"},{"location":"about/roadmap/#breadth","text":"The major breadth-related question ibis is facing is how to grow the number of backends in ibis in a scalable, minimum-maintenance way is an open question. Currently there is a test suite that runs across all backends that xfails tests when a backend doesn\u2019t implement a particular operation. At minimum we need a way to display which backends implement which operations. With the ability to provide custom operations we also need a way to display the custom operations that each backend provides.","title":"Breadth"},{"location":"about/roadmap/#backend-specific-goals","text":"These goals relate to specific backends","title":"Backend-Specific Goals"},{"location":"about/roadmap/#pandas","text":"","title":"pandas"},{"location":"about/roadmap/#speed-up-grouped-rolling-and-simple-aggregations-using-numba","text":"pandas aggregations are quite slow relative to an equivalent numba implementation, for various reasons. Since ibis hides the implementation details of a particular expression we can experiment with using different aggregation implementations.","title":"Speed up grouped, rolling, and simple aggregations using numba"},{"location":"about/roadmap/#dask","text":"","title":"Dask"},{"location":"about/roadmap/#implement-a-dask-backend","text":"There is currently no way in ibis to easily parallelize a computation on a single machine, let alone distribute a computation across machines. Dask provides APIs for doing such things.","title":"Implement a Dask backend"},{"location":"about/roadmap/#spark","text":"Implement a SparkSQL backend SparkSQL provides a way to execute distributed SQL queries similar to other backends supported by ibis such as Impala and BigQuery.","title":"Spark"},{"location":"about/team/","text":"Team Contributors ibis is developed and maintained by a community of volunteer contributors . Active maintainers jreback datapythonista cpcloud kszucs Former maintainers wesm ibis aims to be a welcoming, friendly, diverse and inclusive community. Everybody is welcome, regardless of gender, sexual orientation, gender identity, and expression, disability, physical appearance, body size, race, or religion. We do not tolerate harassment of community members in any form. In particular, people from underrepresented groups are encouraged to join the community.","title":"Team"},{"location":"about/team/#team","text":"","title":"Team"},{"location":"about/team/#contributors","text":"ibis is developed and maintained by a community of volunteer contributors .","title":"Contributors"},{"location":"about/team/#active-maintainers","text":"jreback datapythonista cpcloud kszucs","title":"Active maintainers"},{"location":"about/team/#former-maintainers","text":"wesm ibis aims to be a welcoming, friendly, diverse and inclusive community. Everybody is welcome, regardless of gender, sexual orientation, gender identity, and expression, disability, physical appearance, body size, race, or religion. We do not tolerate harassment of community members in any form. In particular, people from underrepresented groups are encouraged to join the community.","title":"Former maintainers"},{"location":"community/coc/","text":"Code of Conduct Ibis is governed by the NumFOCUS code of conduct : Quote Be kind to others. Do not insult or put down others. Behave professionally. Remember that harassment and sexist, racist, or exclusionary jokes are not appropriate for IBIS. All communication should be appropriate for a professional audience including people of many different backgrounds. Sexual language and imagery is not appropriate. Ibis is dedicated to providing a harassment-free community for everyone, regardless of gender, sexual orientation, gender identity, and expression, disability, physical appearance, body size, race, or religion. We do not tolerate harassment of community members in any form. Thank you for helping make this a welcoming, friendly community for all.","title":"Code of Conduct"},{"location":"community/coc/#code-of-conduct","text":"Ibis is governed by the NumFOCUS code of conduct : Quote Be kind to others. Do not insult or put down others. Behave professionally. Remember that harassment and sexist, racist, or exclusionary jokes are not appropriate for IBIS. All communication should be appropriate for a professional audience including people of many different backgrounds. Sexual language and imagery is not appropriate. Ibis is dedicated to providing a harassment-free community for everyone, regardless of gender, sexual orientation, gender identity, and expression, disability, physical appearance, body size, race, or religion. We do not tolerate harassment of community members in any form. Thank you for helping make this a welcoming, friendly community for all.","title":"Code of Conduct"},{"location":"community/ecosystem/","text":"Ecosystem pandas pandas is a Python package that provides fast, flexible, and expressive data structures designed to make working with \"relational\" or \"labeled\" data both easy and intuitive. It aims to be the fundamental high-level building block for doing practical, real world data analysis in Python. Additionally, it has the broader goal of becoming the most powerful and flexible open source data analysis / manipulation tool available in any language. It is already well on its way towards this goal. SQLAlchemy SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL. SQLAlchemy provides a full suite of well known enterprise-level persistence patterns, designed for efficient and high-performing database access, adapted into a simple and Pythonic domain language. sql_to_ibis sql_to_ibis is a Python package that translates SQL syntax into ibis expressions. This allows users to use one unified SQL dialect to target many different backends, even those that don't traditionally support SQL. A good use case would be ease of migration between databases or backends. Suppose you were moving from SQLite to MySQL or from PostgresSQL to BigQuery. These frameworks all have very subtle differences in SQL dialects, but with sql_to_ibis, these differences are automatically translated in Ibis. Another good use case is pandas, which has no SQL support at all for querying a dataframe. With sql_to_ibis this is made possible. For example, import ibis.backends.pandas import pandas import sql_to_ibis df = pandas . DataFrame ({ \"column1\" : [ 1 , 2 , 3 ], \"column2\" : [ \"4\" , \"5\" , \"6\" ]}) ibis_table = ibis . backends . pandas . from_dataframe ( df , name = \"my_table\" , client = ibis . backends . pandas . PandasClient ({}) ) sql_to_ibis . register_temp_table ( ibis_table , \"my_table\" ) sql_to_ibis . query ( \"select column1, cast(column2 as integer) + 1 as my_col2 from my_table\" ) . execute () This would output a dataframe that looks like: column1 my_col2 1 5 2 6 3 7","title":"Ecosystem"},{"location":"community/ecosystem/#ecosystem","text":"","title":"Ecosystem"},{"location":"community/ecosystem/#pandas","text":"pandas is a Python package that provides fast, flexible, and expressive data structures designed to make working with \"relational\" or \"labeled\" data both easy and intuitive. It aims to be the fundamental high-level building block for doing practical, real world data analysis in Python. Additionally, it has the broader goal of becoming the most powerful and flexible open source data analysis / manipulation tool available in any language. It is already well on its way towards this goal.","title":"pandas"},{"location":"community/ecosystem/#sqlalchemy","text":"SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL. SQLAlchemy provides a full suite of well known enterprise-level persistence patterns, designed for efficient and high-performing database access, adapted into a simple and Pythonic domain language.","title":"SQLAlchemy"},{"location":"community/ecosystem/#sql_to_ibis","text":"sql_to_ibis is a Python package that translates SQL syntax into ibis expressions. This allows users to use one unified SQL dialect to target many different backends, even those that don't traditionally support SQL. A good use case would be ease of migration between databases or backends. Suppose you were moving from SQLite to MySQL or from PostgresSQL to BigQuery. These frameworks all have very subtle differences in SQL dialects, but with sql_to_ibis, these differences are automatically translated in Ibis. Another good use case is pandas, which has no SQL support at all for querying a dataframe. With sql_to_ibis this is made possible. For example, import ibis.backends.pandas import pandas import sql_to_ibis df = pandas . DataFrame ({ \"column1\" : [ 1 , 2 , 3 ], \"column2\" : [ \"4\" , \"5\" , \"6\" ]}) ibis_table = ibis . backends . pandas . from_dataframe ( df , name = \"my_table\" , client = ibis . backends . pandas . PandasClient ({}) ) sql_to_ibis . register_temp_table ( ibis_table , \"my_table\" ) sql_to_ibis . query ( \"select column1, cast(column2 as integer) + 1 as my_col2 from my_table\" ) . execute () This would output a dataframe that looks like: column1 my_col2 1 5 2 6 3 7","title":"sql_to_ibis"}]}